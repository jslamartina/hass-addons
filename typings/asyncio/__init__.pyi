"""Typed stubs for asyncio."""

from collections.abc import Awaitable, Callable, Coroutine, Generator
from typing import Any, Generic, TypeVar

_T = TypeVar("_T")
_TQueue = TypeVar("_TQueue")

class Future(Awaitable[_T]):
    """Future for async operations."""

    def __init__(self, *, loop: AbstractEventLoop | None = ...) -> None: ...
    def set_result(self, result: _T) -> None: ...
    def result(self) -> _T: ...
    def done(self) -> bool: ...
    def cancel(self) -> bool: ...

class AbstractEventLoop:
    """Abstract event loop."""

    def add_signal_handler(
        self, sig: int, callback: Callable[..., Any], *args: Any
    ) -> None: ...
    def is_closed(self) -> bool: ...
    def close(self) -> None: ...
    def stop(self) -> None: ...
    def run_until_complete(self, future: Awaitable[_T]) -> _T: ...
    def create_task(
        self, coro: Coroutine[Any, Any, _T], *, name: str | None = ...
    ) -> Task[_T]: ...
    def time(self) -> float: ...
    def create_future(self) -> Future[Any]: ...

class Loop(AbstractEventLoop):
    """Concrete event loop."""

class AbstractEventLoopPolicy:
    """Abstract event loop policy."""

class Event:
    """Event for synchronization."""

    def __init__(self) -> None: ...
    def set(self) -> None: ...
    def clear(self) -> None: ...
    def is_set(self) -> bool: ...
    async def wait(self) -> bool: ...

class Task(Awaitable[_T]):
    """Task."""

    def __init__(
        self, coro: Coroutine[Any, Any, _T], *, name: str | None = ..., **kwargs: Any
    ) -> None: ...
    def __await__(self) -> Generator[Any, Any, _T]: ...
    def cancel(self, msg: Any = ...) -> bool: ...
    def cancelled(self) -> bool: ...
    def done(self) -> bool: ...
    def result(self) -> _T: ...
    def get_name(self) -> str: ...
    def get_coro(self) -> Coroutine[Any, Any, _T]: ...

def create_task(
    coro: Coroutine[Any, Any, _T], *, name: str | None = ...
) -> Task[_T]: ...

class CancelledError(Exception):
    """Cancelled error."""

def to_thread(func: Callable[..., _T], *args: Any, **kwargs: Any) -> Awaitable[_T]: ...
def new_event_loop() -> Loop: ...
def set_event_loop(loop: AbstractEventLoop | None) -> None: ...
def get_event_loop() -> AbstractEventLoop: ...
def gather(
    *coros: Awaitable[Any], return_exceptions: bool = ...
) -> Awaitable[list[Any]]: ...
def sleep(delay: float, result: Any = ...) -> Coroutine[Any, Any, Any]: ...

class StreamReader:
    """Stream reader."""

    async def read(self, n: int = ...) -> bytes: ...
    def feed_eof(self) -> None: ...
    def at_eof(self) -> bool: ...

class StreamWriter:
    """Stream writer."""

    def write(self, data: bytes | bytearray) -> None: ...
    async def drain(self) -> None: ...
    def close(self) -> None: ...
    async def wait_closed(self) -> None: ...
    def get_extra_info(self, name: str, default: Any = ...) -> Any: ...
    def is_closing(self) -> bool: ...

class Lock:
    """Lock for synchronization."""

    def __init__(self) -> None: ...
    async def __aenter__(self) -> Lock: ...
    async def __aexit__(self, *args: object) -> None: ...
    async def acquire(self) -> None: ...
    def release(self) -> None: ...

class Server:
    """Server."""

    async def __aenter__(self) -> Server: ...
    async def __aexit__(self, *args: object) -> None: ...
    async def serve_forever(self) -> None: ...
    def close(self) -> None: ...
    async def wait_closed(self) -> None: ...
    def is_serving(self) -> bool: ...
    @property
    def sockets(self) -> list[Any]: ...

def start_server(
    client_connected_cb: Callable[[StreamReader, StreamWriter], Awaitable[Any]],
    host: str | None = ...,
    port: int | None = ...,
    **kwargs: Any,
) -> Awaitable[Server]: ...
def open_connection(
    host: str | None = ...,
    port: int | None = ...,
    **kwargs: Any,
) -> Awaitable[tuple[StreamReader, StreamWriter]]: ...
def get_running_loop() -> AbstractEventLoop: ...
def run(coro: Coroutine[Any, Any, Any], **kwargs: Any) -> Any: ...
def wait_for(
    fut: Awaitable[_T], timeout: float | None = ..., **kwargs: Any
) -> Awaitable[_T]: ...
def wait(
    fs: list[Awaitable[Any]], *, timeout: float | None = ..., return_when: str = ...
) -> Awaitable[tuple[set[Awaitable[Any]], set[Awaitable[Any]]]]: ...

class Queue(Generic[_TQueue]):
    """Queue for async operations."""

    def __init__(self, maxsize: int = ...) -> None: ...
    async def put(self, item: _TQueue) -> None: ...
    def put_nowait(self, item: _TQueue) -> None: ...
    async def get(self) -> _TQueue: ...
    def get_nowait(self) -> _TQueue: ...
    def qsize(self) -> int: ...
    def empty(self) -> bool: ...
    def task_done(self) -> None: ...

class QueueFull(Exception):
    """Queue is full."""

def isfuture(obj: Any) -> bool: ...
def iscoroutine(obj: Any) -> bool: ...
