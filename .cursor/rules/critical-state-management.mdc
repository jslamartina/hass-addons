---
description: Critical state management rules
---

# Critical State Management

**Never make state changes that trigger cascading updates.** State management must be carefully controlled to avoid refresh storms and race conditions.

## Rule: Device Offline Threshold

**Don't mark devices offline immediately** - use `offline_count` thresholds to avoid cascading refresh storms.

### Why This Matters

- Marking devices offline too quickly causes them to constantly refresh
- Single network hiccup shouldn't trigger full device rediscovery
- Prevents network storms from rapid state changes
- Reduces unnecessary API calls to Home Assistant

### Correct Pattern

```python
class DeviceMonitor:
    OFFLINE_THRESHOLD = 3  # Number of consecutive failures before marking offline

    def __init__(self):
        self.failure_counts: dict[str, int] = {}

    async def check_device(self, device_id: str) -> bool:
        """Check device health with threshold-based offline detection."""
        try:
            if await self.ping_device(device_id):
                # Reset failure count on success
                self.failure_counts[device_id] = 0
                await self.mark_device_online(device_id)
                return True
            else:
                # Increment failure count
                self.failure_counts[device_id] = self.failure_counts.get(device_id, 0) + 1

                if self.failure_counts[device_id] >= self.OFFLINE_THRESHOLD:
                    logger.warning(
                        f"Device offline after {self.OFFLINE_THRESHOLD} failures",
                        extra={"device_id": device_id}
                    )
                    await self.mark_device_offline(device_id)
                else:
                    logger.debug(
                        f"Device ping failed ({self.failure_counts[device_id]}/{self.OFFLINE_THRESHOLD})",
                        extra={"device_id": device_id}
                    )
                return False
        except Exception as e:
            logger.error(f"Device check error: {e}", extra={"device_id": device_id})
            return False
```

### Anti-Pattern

```python
## ❌ WRONG: Immediate offline marking
async def check_device(self, device_id: str) -> bool:
    if not await self.ping_device(device_id):
        await self.mark_device_offline(device_id)  # Causes flickering!
        return False
    return True

## ❌ WRONG: No state clearing on success
if consecutive_failures >= OFFLINE_THRESHOLD:
    mark_device_offline(device_id)
    # Forgot to reset counter when device comes back online!
```

## Rule: No Autorefresh After ACKs

**Don't add automatic refresh after command ACKs** - causes cascading refreshes that break subsequent commands.

### Why This Matters

- Autorefresh can trigger another refresh in a loop
- Creates refresh storms that block new commands
- Device state should be updated locally from ACK payload
- Mesh refresh should only happen on explicit user request or schedule

### Correct Pattern

```python
async def handle_command_ack(self, device_id: str, ack_payload: dict) -> None:
    """Handle ACK without triggering refresh."""
    # ✅ CORRECT: Update local state from ACK
    new_state = ack_payload.get("state")
    brightness = ack_payload.get("brightness")

    # Update device object
    device = self.devices[device_id]
    device.state = new_state
    device.brightness = brightness
    device.last_seen = datetime.now()

    # Publish to MQTT (state update only)
    await self.mqtt_publish_state(device_id, {
        "state": new_state,
        "brightness": brightness
    })

    logger.info(
        "State updated from ACK",
        extra={
            "device_id": device_id,
            "state": new_state,
            "brightness": brightness
        }
    )

    # ✅ NO refresh triggered here
```

### Anti-Pattern

```python
## ❌ WRONG: Auto-refresh after ACK
async def handle_command_ack(self, device_id: str, ack_payload: dict) -> None:
    # Update state
    await self.update_device_state(device_id, ack_payload)

    # ❌ WRONG: Triggers another refresh
    await self.refresh_all_devices()  # Causes cascade!

## ❌ WRONG: Refresh triggers command which triggers refresh
async def refresh_device(self, device_id: str) -> None:
    state = await self.get_device_state(device_id)
    if state != self.cached_state:
        await self.send_state_sync_command(device_id)  # This triggers another ACK → refresh!
```

## Rule: State Update Ordering

**Always update internal state before external notifications** - prevents race conditions.

### Correct Pattern

```python
async def set_device_state(self, device_id: str, new_state: str) -> bool:
    """Set device state with proper ordering."""
    # 1. Send command to device
    ack = await self.send_command(device_id, {"state": new_state})

    if not ack:
        return False

    # 2. Update internal state FIRST
    self.devices[device_id].state = new_state
    self.devices[device_id].last_updated = datetime.now()

    # 3. Notify external systems AFTER internal update
    await self.mqtt_publish_state(device_id, {"state": new_state})
    await self.fire_state_changed_event(device_id)

    return True
```

### Anti-Pattern

```python
## ❌ WRONG: Update external before internal
async def set_device_state(self, device_id: str, new_state: str) -> bool:
    # Notify MQTT first
    await self.mqtt_publish_state(device_id, {"state": new_state})

    # Send command (might fail!)
    ack = await self.send_command(device_id, {"state": new_state})

    # Now internal state is out of sync with what we published
    if ack:
        self.devices[device_id].state = new_state
```

## Rule: Avoid State Polling Loops

**Don't poll for state changes continuously** - use event-driven updates or scheduled intervals.

### Correct Pattern

```python
class DeviceManager:
    def __init__(self):
        self.poll_interval = 300  # 5 minutes

    async def start_monitoring(self):
        """Event-driven monitoring with scheduled health checks."""
        # Event-driven: respond to ACKs immediately
        self.mqtt_client.on_message = self.handle_device_message

        # Scheduled: periodic health check only
        asyncio.create_task(self.scheduled_health_check())

    async def scheduled_health_check(self):
        """Periodic health check, not continuous polling."""
        while True:
            await asyncio.sleep(self.poll_interval)
            await self.check_all_devices_health()
```

### Anti-Pattern

```python
## ❌ WRONG: Continuous polling
async def monitor_devices(self):
    while True:
        for device in self.devices:
            state = await self.get_device_state(device.id)  # Expensive!
            if state != device.cached_state:
                await self.update_state(device.id, state)
        await asyncio.sleep(1)  # Polling every second!
```

## Rule: Optimistic State Updates

**Update UI optimistically but rollback on failure** - provides responsive UX while maintaining consistency.

### Correct Pattern

```python
async def set_light_state(self, device_id: str, state: bool) -> bool:
    """Optimistic update with rollback on failure."""
    # Save current state for rollback
    previous_state = self.devices[device_id].state

    # 1. Update state optimistically (immediate UI feedback)
    self.devices[device_id].state = state
    await self.mqtt_publish_state(device_id, {"state": state})

    logger.debug(
        "Optimistic state update",
        extra={"device_id": device_id, "state": state}
    )

    # 2. Send command to device
    try:
        ack = await asyncio.wait_for(
            self.send_command(device_id, {"state": state}),
            timeout=5.0
        )

        if ack:
            logger.info("State confirmed by device", extra={"device_id": device_id})
            return True
        else:
            # 3. Rollback on failure
            logger.warning("Command failed, rolling back", extra={"device_id": device_id})
            self.devices[device_id].state = previous_state
            await self.mqtt_publish_state(device_id, {"state": previous_state})
            return False

    except asyncio.TimeoutError:
        # Rollback on timeout
        logger.error("Command timeout, rolling back", extra={"device_id": device_id})
        self.devices[device_id].state = previous_state
        await self.mqtt_publish_state(device_id, {"state": previous_state})
        return False
```

### Anti-Pattern

```python
## ❌ WRONG: Wait for ACK before UI update (slow UX)
async def set_light_state(self, device_id: str, state: bool) -> bool:
    # Send command first (user waits...)
    ack = await self.send_command(device_id, {"state": state})

    # Only update after ACK (perceived lag)
    if ack:
        self.devices[device_id].state = state
        await self.mqtt_publish_state(device_id, {"state": state})

    return ack

## ❌ WRONG: Optimistic update without rollback
async def set_light_state(self, device_id: str, state: bool) -> bool:
    # Update state
    self.devices[device_id].state = state
    await self.mqtt_publish_state(device_id, {"state": state})

    # Send command (might fail!)
    ack = await self.send_command(device_id, {"state": state})

    # No rollback - state now incorrect!
    return ack
```

## Related

- See `critical-commands.mdc` for command callback patterns and ACK handling
- See `docs/developer/architecture.md` for state flow architecture
- See `logging-mandatory.mdc` for logging state changes with before/after values
